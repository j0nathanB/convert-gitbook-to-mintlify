/**
 * Validate that all internal links in .mdx files resolve to existing files.
 *
 * Parses every .mdx file for markdown-style links and JSX href attributes,
 * filters to internal (relative) links, and verifies each target exists in
 * the output directory.  Anchor fragments are checked where feasible by
 * scanning the target file for a matching heading.
 */

import { readFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { existsSync } from 'node:fs';
import { glob } from 'glob';

import type { ValidationResult } from './runner.js';

/**
 * Check all internal links across .mdx files in `outputDir`.
 */
export async function checkLinks(outputDir: string): Promise<ValidationResult> {
  const errors: ValidationResult['errors'] = [];

  const files = await glob('**/*.mdx', { cwd: outputDir, nodir: true });

  if (files.length === 0) {
    return { passed: true, errors: [] };
  }

  // Build a set of all known file paths (without extension, and with extension)
  // for fast lookup.
  const knownFiles = new Set<string>();
  for (const f of files) {
    knownFiles.add(f);
    // Also add without .mdx extension, since Mintlify nav paths omit it.
    if (f.endsWith('.mdx')) {
      knownFiles.add(f.slice(0, -4));
    }
  }

  // Regex to capture markdown links: [text](target)
  // Avoids matching image syntax ![alt](src).
  const mdLinkRe = /(?<!!)\[(?:[^\]]*)\]\(([^)]+)\)/g;

  // Regex to capture href="..." attributes in JSX / HTML tags.
  const hrefRe = /href=["']([^"']+)["']/g;

  for (const file of files) {
    const fullPath = join(outputDir, file);
    const content = await readFile(fullPath, 'utf-8');
    const fileDir = dirname(file);

    const links = new Set<string>();

    for (const match of content.matchAll(mdLinkRe)) {
      links.add(match[1]);
    }
    for (const match of content.matchAll(hrefRe)) {
      links.add(match[1]);
    }

    for (const rawLink of links) {
      // Skip external URLs and protocol-relative links.
      if (/^https?:\/\/|^\/\/|^mailto:|^tel:/i.test(rawLink)) {
        continue;
      }

      // Split off anchor fragment.
      const [linkPath, anchor] = rawLink.split('#', 2);

      // If only an anchor (e.g., #section), check within the same file.
      if (linkPath === '') {
        if (anchor) {
          const headingExists = await hasHeading(join(outputDir, file), anchor);
          if (!headingExists) {
            errors.push({
              file,
              link: rawLink,
              error: `Anchor "#${anchor}" not found in same file`,
            });
          }
        }
        continue;
      }

      // Resolve relative path against the directory of the source file.
      let resolved: string;
      if (linkPath.startsWith('/')) {
        // Absolute path within the docs root.
        resolved = linkPath.slice(1);
      } else {
        resolved = join(fileDir, linkPath);
      }

      // Normalize (remove trailing slashes, etc.)
      resolved = resolved.replace(/\/$/, '');

      // Check existence: try exact path, then with .mdx extension, then as
      // directory with index.mdx.
      const candidates = [
        resolved,
        resolved + '.mdx',
        join(resolved, 'index.mdx'),
      ];

      const found = candidates.some(
        (c) => knownFiles.has(c) || existsSync(join(outputDir, c)),
      );

      if (!found) {
        errors.push({
          file,
          link: rawLink,
          error: `Target "${resolved}" does not exist in output directory`,
        });
        continue;
      }

      // If there is an anchor, verify the heading exists in the target file.
      if (anchor) {
        const targetFile = candidates.find(
          (c) => knownFiles.has(c) || existsSync(join(outputDir, c)),
        );
        if (targetFile) {
          const headingExists = await hasHeading(join(outputDir, targetFile), anchor);
          if (!headingExists) {
            errors.push({
              file,
              link: rawLink,
              error: `Anchor "#${anchor}" not found in target "${targetFile}"`,
            });
          }
        }
      }
    }
  }

  return {
    passed: errors.length === 0,
    errors,
  };
}

/**
 * Check whether a file contains a heading that would generate the given anchor.
 *
 * Heading anchors are generated by lowercasing, replacing spaces with hyphens,
 * and stripping non-alphanumeric characters (except hyphens).
 */
async function hasHeading(filePath: string, anchor: string): Promise<boolean> {
  try {
    const content = await readFile(filePath, 'utf-8');

    // Extract all markdown headings (ATX-style: # Heading).
    const headingRe = /^#{1,6}\s+(.+)$/gm;
    const normalizedAnchor = normalizeAnchor(anchor);

    for (const match of content.matchAll(headingRe)) {
      const headingText = match[1].trim();
      if (normalizeAnchor(headingText) === normalizedAnchor) {
        return true;
      }
    }

    return false;
  } catch {
    // If we cannot read the file, skip anchor checking.
    return true;
  }
}

/**
 * Normalize a heading string to its expected anchor form.
 */
function normalizeAnchor(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}
